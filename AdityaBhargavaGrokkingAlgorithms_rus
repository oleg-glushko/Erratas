Глава 1
Полный код бинарного поиска включает следующую строку:

mid = (low + high)

На самом деле она должна быть:

mid = (low + high) // 2

Там же, чуть выше, в строке:

low = 0///

необходимо убрать три слэша, следующие за 0.

------------------------

На протяжении данной книги я упоминаю null. Null в Python представлен ключевым словом None. Т.е., если вы хотите узнать, не является ли что-то несуществующим, сравнивайте его с None.

------------------------

Для бинарного поиска, в худшем случае, вам придется проверить log n элементов. Для списка из 8 элементов log 8 == 3, потому что 2^3 == 8. Итак, для списка из 8 чисел вам придется проверить не более 3 чисел.

Для 8 чисел нам, на самом деле, в худшем случае понадобится проверить 4 числа.

------------------------

В примере с ракетой я написал:

Боб проводит бинарный поиск с 1 миллиардом элементов, и на это уходит 30 мс (log~2~ 1 000 000 000 равен приблизительно 30). «32 мс!» - думает Боб.

Сначала я указал 30 мс, а потом 32 мс. В обоих случаях должно быть 30 мс.

------------------------

Для O(n!) указано некорректно время построения:

8,6 x 10^505 должно быть 2,7 x 10^498
5,4 x 10^2638 должно быть 1,72 x 10^2631.


Глава 2
Страница 51: «Быстрая сортировка – эффективный алгоритм сортировки, которые выполняется за время O(n log n). Но мы займемся этой темой в следующей главе!» Обсуждение быстрой сортировки на самом деле происходит в главе 4, а не в следующей, третьей главе.



Глава 3
На странице 63 этот фрагмент:

def countdown(i):

print i

countdown(i-1)

Должен быть отформатирован так (отступ пробелами):

def countdown(i):

====> print i

====> countdown(i-1)

------------------------

На странице 64, в функции countdown, базовый сценарий содержит if i <= 0, но в приведённой ниже иллюстрации я говорю if i <= 1. В обоих случаях должно быть if i <= 1.

------------------------

На странице 66 код функции bye() должен быть оформлен с такими же отступами, как и greet2().



Глава 4
На странице 81 я показываю, как ферму можно разделить на участки размером 80x80. Но сетка при этом показана 14x8. Она должна быть 21x8.

------------------------

Я говорю о разделении массива в быстрой сортировке, состоящего из пяти элементов: «Вот как выглядят все варианты разделения этого массива в зависимости от выбранного опорного элемента:» Сразу после это строки я привожу большой рисунков, показывающий различные способы, которыми данный массив может быть разделён. Первое разделение должно быть: [ ] <1> [ 3, 5, 2, 4 ].

------------------------

В данной главе, в различных местах, я утверждаю:

лучше выбирать в качестве опорного случайный элемент
лучше выбирать в качестве опорного средний элемент.
Очевидно, что оба эти высказывания не могут быть корректными одновременно. Сценарий со временем выполнения быстрой сортировки в среднем O(n lg n) выполняется только если вы выбираете в качестве опорного элемента случайный. Таким образом, выбирайте в качестве опорного случайный элемент.



Глава 7
В изображении на странице 156 у взвешенного графа должно быть примечание «(алгоритм Дейкстры)»

------------------------

На странице 159 я говорю, что алгоритм Дейкстры работает только с направленными ацикличными графами. Это не так, он работает даже при наличии цикличности, если при это у цикла положительный вес.

------------------------

На странице 170 есть строка «Алгоритм Дейкстры предположил, что, поскольку вы обрабатываете узел «постер», к этому узлу невозможно добраться быстрее.» В данном примере было бы уместней использовать вместо слова «быстрее» термин «дешевле».

------------------------

В разделе «История одного обмена» на многих изображениях с таблицами присутствуют пустые строки в поле «Узел», это неверно, там должны быть значения «Пластинка, Постер, Гитара, Барабан, Пианино», именно в таком порядке.

------------------------

Алгоритм Дейкстры, страница 172.

В верхней части страницы устанавливаются веса вида start -> A равным 6 и start -> B равным 2. Однако в нижней части этой же страницы указанные веса перепутаны:

>>> print graph['start']['a']

2

>>> print graph['start']['b']

6

Приведённые в коде выше значения следует поменять местами.

------------------------

На странице 180, в первых двух строчках кода пропущена буква f, должно быть:

def find_lowest_cost_node (costs):

   lowest_cost = float("inf")



Глава 8
Для n станций оно потребует времени O(2^n).

В этой строке следует читать «2^n подмножеств», неправильно указана степень и слово «станций».

------------------------

На странице 192 стрелка «Новый синтаксис! Эта операция называется “пересечением множеств”» должна указывать на первую, а не вторую строку кода.

------------------------

В фрагменте кода на середине страницы 195 последние две строчки должны иметь такой отступ, чтобы они находились внутри цикла while:

while states_needed:

   ....

   states_needed -= states_covered

   final_stations.add(best_station)

------------------------

В конце страницы 195 точный алгоритм займёт O(2^n), а не O(n!) времени

------------------------

В данной главе я неправильно написал имя игрока в американский футбол, Брэндона Маршалла.

------------------------

В ответе 8.4 на вопрос к этой главе я указал поиск в ширину как жадный алгоритм, но это неверно.

Глава 9
На странице 219, в левой нижней ячейке сетки должно быть “$2000”, а не “$3500”.

------------------------

На странице 230, в левой нижней ячейке сетки должно быть “1”, а не “0”, то же и для следующей сетки, на странице 231, так как в обоих случаях H == H.

Глава 10
В данной главе я упоминал, что Netflix для рекомендаций использует алгоритм k ближайших соседей, однако один из читателей указал, что они применяют коллаборативную фильтрацию.

------------------------

На странице 251, в примере о классификации спам / не спам, я говорю о «нигерийском принце». Данный пример не очень содержателен, поэтому его следует убрать.



Глава 11
В данной главе я рассказываю об алгоритмах SHA и том, как они применяются для паролей. Люди обнаружили, что данные алгоритмы недостаточно безопасны. Текущая отраслевая рекомендация предполагает использование одного из следующих алгоритмов: bcrypt, scrypt или PBKDF2. Вот что пишет один из читателей:

Хеши паролей сами по себе являются отдельным классом алгоритмов. Хеш-алгоритм вроде SHA-512 может быть «безопасным» с точки зрения относительного отсутствия предсказуемых коллизий, однако всё равно не подходит для хешей паролей, если он легко рассчитывается. Bcrypt создан намеренно сложным для вычислений с точки зрения циклов процессора, а scrypt ресурсоёмок в пересчёте на потребляемую память.

------------------------

Алгоритм Диффи-Хеллмана не равнозначен асимметричному шифрованию. Вот комментарий, который я получил от читателя:

шифрование, безо всяких сомнений, вызывает интерес! Проблема обмена ключами относится к вопросу безопасного шифрования, но это всё же разные вещи. Всё равно что сказать, что проблема распределения настоящих, металлических ключей авторизованным пользователям относится к вопросу проектирования безопасного замка, но они ведь не являются одним и тем же.

Уит Диффи и Мартин Хеллман изобрели способ согласования двумя сторонами секретного ключа при невозможности человеком посередине узнать данный секрет. Это иная проблема, отличная от вопроса использования секретного ключа для шифрации чего-либо, представленного в открытом виде. При обмене ключа по алгоритму Диффи-Хеллмана, данный ключ шифрования остаётся в секрете. Такой обмен ни в коей мере не является криптосистемой. Уит Диффи и Мартин Хеллман также выдвинули идею асимметричного шифрования, но не предоставили реализующего её алгоритма. Но это уже другая тема, отличная от обмена ключом Диффи-Хеллмана.

С другой стороны, шифрование RSA является асимметричной криптосистемой (фактически, первой подобной системой, широко известной публике). RSA на сегодняшний день, вероятно, не самая лучшая асимметричная криптосистема (мы обеспокоены вопросом её стойкости к квантовому криптоанализу), но всё ещё широко применяется и относительно проста для понимания.
