# Адитья Бхаргава - Грокаем алгоритмы. Иллюстрированное пособие для программистов и любопытствующих
Список ошибок для [pdf-версии](https://www.piter.com/collection/all/product/grokaem-algoritmy-illyustrirovannoe-posobie-dlya-programmistov-i-lyubopytstvuyuschih-2), выпущенной в 2017 г. издательством "Питер". Составлен на основе [Errata](http://adit.io/errata.html) английской версии и найденных мной при прочтении русского издания. 

## Глава 1

Полный код бинарного поиска включает следующую строку:

```python
mid = (low + high)
```

На самом деле она должна быть:

```python
mid = (low + high) // 2
```


Там же, чуть выше, в строке:

```python
low = 0///
```

необходимо убрать три слэша, следующие за 0.

---

На протяжении данной книги я упоминаю null. Null в Python представлен ключевым словом None. Т.е., если вы хотите узнать, не является ли что-то несуществующим, сравнивайте его с None.

---

_Для бинарного поиска, в худшем случае, вам придется проверить `log n` элементов. Для списка из 8 элементов `log 8 == 3`, потому что `2^3 == 8`. Итак, для списка из 8 чисел вам придется проверить не более 3 чисел._

Для 8 чисел нам, на самом деле, в худшем случае понадобится проверить 4 числа.

---

В примере с ракетой я написал:

_Боб проводит бинарный поиск с 1 миллиардом элементов, и на это уходит 30 мс (log~2~ 1 000 000 000 равен приблизительно 30). «32 мс!» - думает Боб._

Сначала я указал 30 мс, а потом 32 мс. В обоих случаях должно быть 30 мс.

---

Для O(n!) указано некорректно время построения:

8,6 x 10^505 должно быть 2,7 x 10^498
5,4 x 10^2638 должно быть 1,72 x 10^2631.


## Глава 2

Страница 51: _«Быстрая сортировка – эффективный алгоритм сортировки, которые выполняется за время O(n log n). Но мы займемся этой темой в следующей главе!»_

Обсуждение быстрой сортировки на самом деле происходит в главе 4, а не в следующей, третьей главе.


## Глава 3

На странице 63 этот фрагмент:

```python
def countdown(i):
print i
countdown(i-1)
```

Должен быть отформатирован так (отступ пробелами):

```python
def countdown(i):
    print i
    countdown(i-1)
```

---

На странице 64, в функции `countdown`, базовый сценарий содержит `if i <= 0`, но в приведённой ниже иллюстрации я говорю `if i <= 1`. В обоих случаях должно быть `if i <= 1`.

---

На странице 66 код функции `bye()` должен быть оформлен с такими же отступами, как и `greet2()`.


## Глава 4

На странице 81 я показываю, как ферму можно разделить на участки размером 80x80. Но сетка при этом показана 14x8. Она должна быть 21x8.

---

Я говорю о разделении массива в быстрой сортировке, состоящего из пяти элементов: _«Вот как выглядят все варианты разделения этого массива в зависимости от выбранного опорного элемента:»_ Сразу после это строки я привожу большой рисунков, показывающий различные способы, которыми данный массив может быть разделён. Первое разделение должно быть: `[ ] <1> [ _3, 5, 2, 4 ]`.

---

В данной главе, в различных местах, я утверждаю:

_лучше выбирать в качестве опорного случайный элемент_

_лучше выбирать в качестве опорного средний элемент_

Очевидно, что оба эти высказывания не могут быть корректными одновременно. Сценарий со временем выполнения быстрой сортировки в среднем `O(n lg n)` выполняется только если вы выбираете в качестве опорного элемента случайный. Таким образом, выбирайте в качестве опорного случайный элемент.


## Глава 7

В изображении на странице 156 у взвешенного графа должно быть примечание «(алгоритм Дейкстры)».

---

На странице 159 я говорю, что алгоритм Дейкстры работает только с направленными ацикличными графами. Это не так, он работает даже при наличии цикличности, если при это у цикла положительный вес.

---

На странице 170 есть строка _«Алгоритм Дейкстры предположил, что, поскольку вы обрабатываете узел «постер», к этому узлу невозможно добраться быстрее.»_. В данном примере было бы уместней использовать вместо слова «быстрее» термин «дешевле».

---

В разделе «История одного обмена» на многих изображениях с таблицами присутствуют пустые строки в поле «Узел», это неверно, там должны быть значения «Пластинка, Постер, Гитара, Барабан, Пианино», именно в таком порядке.

---

Алгоритм Дейкстры, страница 172.

В верхней части страницы устанавливаются веса вида `start -> A` равным 6 и `start -> B` равным 2. Однако в нижней части этой же страницы указанные веса перепутаны:

```python
>>> print graph['start']['a']
2
>>> print graph['start']['b']
6
```

Приведённые в коде выше значения следует поменять местами.

---

На странице 180, в первых двух строчках кода пропущена буква f, должно быть:

```python
def find_lowest_cost_node (costs):
   lowest_cost = float("inf")
```


## Глава 8
_Для n станций оно потребует времени `O(2^n)`._

В этой строке следует читать «2^n подмножеств», неправильно указана степень и слово «станций».

---

На странице 192 стрелка _«Новый синтаксис! Эта операция называется “пересечением множеств”»_ должна указывать на первую, а не вторую строку кода.

---

В фрагменте кода на середине страницы 195 последние две строчки должны иметь такой отступ, чтобы они находились внутри цикла while:

```python
while states_needed:
    ...
    states_needed -= states_covered
    final_stations.add(best_station)
```

---

В конце страницы 195 точный алгоритм займёт `O(2^n)`, а не `O(n!)` времени

---

В данной главе я неправильно написал имя игрока в американский футбол, [Брэндона Маршалла](https://ru.wikipedia.org/wiki/Маршалл,_Брэндон).

---

В ответе 8.4 на вопрос к этой главе я указал поиск в ширину как жадный алгоритм, но это неверно.


## Глава 9

На странице 219, в левой нижней ячейке сетки должно быть “$2000”, а не “$3500”.

---

На странице 230, в левой нижней ячейке сетки должно быть “1”, а не “0”, то же и для следующей сетки, на странице 231, так как в обоих случаях `H == H`.


## Глава 10

В данной главе я упоминал, что Netflix для рекомендаций использует алгоритм _k_ ближайших соседей, однако один из читателей указал, что они применяют коллаборативную фильтрацию.

---

На странице 251, в примере о классификации спам / не спам, я говорю о «нигерийском принце». Данный пример не очень содержателен, поэтому его следует убрать.


## Глава 11
В данной главе я рассказываю об алгоритмах SHA и том, как они применяются для паролей. Люди обнаружили, что данные алгоритмы недостаточно безопасны. Текущая отраслевая рекомендация предполагает использование одного из следующих алгоритмов: bcrypt, scrypt или PBKDF2. Вот что пишет один из читателей:

_Хеши паролей сами по себе являются отдельным классом алгоритмов. Хеш-алгоритм вроде SHA-512 может быть «безопасным» с точки зрения относительного отсутствия предсказуемых коллизий, однако всё равно не подходит для хешей паролей, если он легко рассчитывается. Bcrypt создан намеренно сложным для вычислений с точки зрения циклов процессора, а scrypt ресурсоёмок в пересчёте на потребляемую память._

---

Алгоритм Диффи-Хеллмана не равнозначен асимметричному шифрованию. Вот комментарий, который я получил от читателя:

_Шифрование, безо всяких сомнений, вызывает интерес! Проблема обмена ключами относится к вопросу безопасного шифрования, но это всё же разные вещи. Всё равно что сказать, что проблема распределения настоящих, металлических ключей авторизованным пользователям относится к вопросу проектирования безопасного замка, но они ведь не являются одним и тем же._

_Уит Диффи и Мартин Хеллман изобрели способ согласования двумя сторонами секретного ключа при невозможности человеком посередине узнать данный секрет. Это иная проблема, отличная от вопроса использования секретного ключа для шифрации чего-либо, представленного в открытом виде. При обмене ключа по алгоритму Диффи-Хеллмана, данный ключ шифрования остаётся в секрете. Такой обмен ни в коей мере не является криптосистемой. Уит Диффи и Мартин Хеллман также выдвинули идею асимметричного шифрования, но не предоставили реализующего её алгоритма. Но это уже другая тема, отличная от обмена ключом Диффи-Хеллмана._

_С другой стороны, шифрование RSA является асимметричной криптосистемой (фактически, первой подобной системой, широко известной публике). RSA на сегодняшний день, вероятно, не самая лучшая асимметричная криптосистема (мы обеспокоены вопросом её стойкости к квантовому криптоанализу), но всё ещё широко применяется и относительно проста для понимания._
